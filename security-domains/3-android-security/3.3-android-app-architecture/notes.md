# 3.3.1 Manifest.xml Structure

---

## What is AndroidManifest.xml?
- The **central configuration file** of every Android app.  
- Defines **app components, permissions, metadata, and security attributes**.  
- Required in every APK → tells Android how the app should behave.

---

## Core Responsibilities
1. **Declares Components**  
   - Activities, Services, Broadcast Receivers, Content Providers.  
   - Each declared with attributes like `exported`, `permission`.

2. **Manages Permissions**  
   - **Uses-Permissions**: what the app needs (e.g., `INTERNET`, `READ_SMS`).  
   - **Defines-Permissions**: what the app enforces on others (e.g., custom `signature`-level permission).

3. **Provides Metadata**  
   - App name, icon, version, min/target SDKs, themes.  
   - Declares launchable activity with `<intent-filter>`.

4. **Controls Security & Behavior**  
   - Attributes like `android:exported`, `android:debuggable`, `android:allowBackup` influence app security posture.

---

## Security-Sensitive Attributes
- **`android:exported`**  
  - If `true`, other apps can access the component.  
  - Must be explicitly declared from Android 12+.  
  - Common cause of component hijacking if misused.  

- **`android:permission`**  
  - Restricts which apps can access components.  
  - Use `signature`-level permissions for highly sensitive components.  

- **`android:debuggable`**  
  - Should always be `false` in production.  
  - If left `true`, attackers can attach debuggers and extract memory.  

- **`android:allowBackup`**  
  - If `true`, app data can be backed up via adb.  
  - Risk: attacker with device access can dump sensitive data.  
  - Best to set `false` for apps handling sensitive data.  

---

## Common Security Risks
- **Exported components** → exploited for task hijacking, service injection, or data leaks.  
- **Over-permissioning** → app requests more permissions than needed, expanding attack surface.  
- **Debuggable release builds** → enable reverse engineering and runtime tampering.  
- **Improper intent-filters** → can be abused for phishing or component hijacking.  
- **Enabled backups** → allow sensitive data exfiltration from device backups.  

---

## Best Practices
- Apply **least privilege**: request only necessary permissions.  
- Use `exported=false` unless absolutely required.  
- Protect exported components with strong permissions (`signature`).  
- Always set `debuggable=false` in release builds.  
- Disable backups (`allowBackup=false`) for sensitive apps like banking/messaging.  
- Validate all incoming Intents for expected actions and data.  

---

## ✅ Interview One-Liners
- “Manifest.xml is the app’s blueprint — misconfigurations here create critical attack surfaces.”  
- “Never export sensitive components; only launcher activities require it.”  
- “Always disable `debuggable` and backups in production for security.”  
- “Use signature-level permissions to protect sensitive inter-app communication.”

# 3.3.2 App Signing & Certificates

## Overview
- Every Android APK must be digitally signed.  
- Signatures prove developer identity and app integrity.  
- Updates only allowed if signed with the **same key**.

---

## Keys & Certificates
- **Debug Key:** Auto-generated by Android Studio, only for testing.  
- **Release Key:** Custom, unique to developer, required for production apps. Must be stored securely.  
- Certificates can be self-signed; Android doesn’t require CA-signed certs.

---

## How Signing Works
1. Build APK → hash contents.  
2. Hash signed with **private key** → signature created.  
3. Signature + public cert stored in APK (`META-INF/`).  
4. On install/update: Android verifies integrity + checks cert matches installed app.  

## 3.3.2 App Signing & Certificates

### Deep Dive
- Every Android app **must be signed** before installation.  
- Signing ensures:
  - **Integrity** → APK not tampered after signing.  
  - **Identity** → Updates accepted only if signed with same key.  
  - **Trust** → Users & OS validate authenticity.  

### Signing Schemes
- **v1 (JAR Signing):**
  - Verifies individual files only.  
  - Vulnerable to **Janus attack** → attackers can add/modify files undetected.  
- **v2 (APK Signature Scheme):**
  - Introduced in Android 7.0.  
  - Verifies entire APK → prevents Janus.  
- **v3 (Android 9+):**
  - Adds support for **key rotation** → critical if signing key compromised.  
- **v4 (Android 11+):**
  - Enables **incremental installs** with signature validation.  

### Key Security
- **Release key**: Used to sign production builds (must be securely stored).  
- **Upload key**: Used by developers to upload APKs to Play Console (can be rotated easily if compromised).  
- **Play App Signing**: Google holds the signing key securely; devs only manage upload key.  

### Risks
- **Compromised signing key** = attacker can push “legitimate” malware updates.  
- **v1-only apps** vulnerable to file injection/modification attacks.  
- **Lost signing key** = app continuity breaks (can’t update users).  

### Best Practices
- Always use **Play App Signing** with v2/v3 scheme.  
- Store keys in **HSMs or secure keystores**, never GitHub/local.  
- Rotate upload keys if leaked; coordinate with Google for signing key migration.  
- Disable debuggable & backup in production (`android:debuggable="false"`, `android:allowBackup="false"`).  

---

### Interview One-Liner
“App signing is the foundation of Android trust. v1-only apps allow file injection, while compromised signing keys allow attackers to ship malware as legitimate updates. Play App Signing with v3+ enables safe key rotation, making secure storage of signing keys non-negotiable.”  

## 3.3.3 Build Variants & Configurations

### What are Build Variants?
- **Build Variant = Build Type × Product Flavor.**
- **Build Types (default):**
  - **Debug:** For dev/testing, signed with debug key, debuggable=true, includes logs/test configs.  
  - **Release:** For production, signed with release key, debuggable=false, optimized & obfuscated.  
- **Product Flavors:** Variants for different markets/users (e.g., free vs paid, internal vs external).  

---

### Security Risks
- **Debug builds in production:** Attackers can attach debuggers, exploit verbose logs, access hidden features.  
- **Exposed test endpoints:** If staging/test configs are shipped, attackers may exploit weaker environments.  
- **Leaked API keys/secrets:** Hardcoded in build.gradle or resources → extractable from APK.  
- **Weak obfuscation:** Poor ProGuard/R8 rules make reverse engineering easy.  
- **Hardcoded feature flags:** Attackers may flip them to unlock features.  

---

### Sensitive Gradle Configurations
- Control app signing, endpoints, feature flags, API keys, ProGuard/R8.  
- Mistake: mixing production secrets in debug configs or leaving staging endpoints exposed.  

---

### Best Practices
- Keep debug and release builds **strictly separate**.  
- Never ship **debuggable builds**.  
- Store secrets securely, not in build files.  
- Enable **R8/ProGuard obfuscation** for release builds.  
- Validate that **release variants** connect only to production endpoints.  
- Use CI/CD pipelines to catch debug or misconfigured builds before release.  

---

### Interview One-Liner
“Build variants let devs manage debug vs release vs flavor builds. Security depends on strict separation: never ship debuggable builds, secure configs, and enforce obfuscation to prevent reverse engineering.”

## 3.3.4 Package Structure & APK Contents

### What is an APK?
- APK = Android Package Kit, a ZIP archive containing app code, resources, and metadata.  
- Attackers/pentesters decompile APKs to find secrets and vulnerabilities.  

---

### Common APK Contents
- **AndroidManifest.xml** → app config, permissions, components.  
- **classes.dex** → compiled bytecode, reverse-engineered for logic & crypto routines.  
- **resources.arsc** → compiled resources, can leak API keys or flags.  
- **res/** → layouts, XML, images; modifiable to change behavior.  
- **lib/** → native libraries (.so), often contain memory risks or secrets.  
- **META-INF/** → certificates & signatures for integrity.  
- **assets/** → arbitrary developer files (configs, ML models, etc.).  

---

### Security Risks
- **Hardcoded secrets** → API keys, tokens, passwords often exposed.  
- **Reverse engineering** → weak obfuscation makes business logic visible.  
- **Tampering/repackaging** → attackers modify APK and re-sign with new key.  
- **Native library flaws** → buffer overflows, unsafe JNI calls.  
- **Exposed assets** → proprietary data/models stolen or modified.  

---

### Pentesting Tools
- `apktool`, `jadx`, `dex2jar`, `strings` → static analysis.  
- `objection`, `frida` → dynamic analysis/runtime tampering.  
- **MobSF** → automated static/dynamic APK security testing.  

---

### Best Practices
- Do not hardcode secrets in code/resources.  
- Use **ProGuard/R8 obfuscation** to protect bytecode.  
- Sign with **APK Signature Scheme v2/v3**.  
- Store sensitive logic on server-side where possible.  
- Scan APKs pre-release for leaks & misconfigurations.  
- Detect tampered apps with **Play Integrity API / SafetyNet**.  

---

### Interview One-Liner
“APK is just a ZIP archive — without obfuscation and secret management, attackers can reverse engineer, steal secrets, or repackage apps. Secure signing, obfuscation, and CI/CD checks are key defenses.”

### Q2 — Subjective: Banking App APK Risks

**Question:**  
During a pentest of a banking app, you decompile the APK and discover:  
- Sensitive logic for **PIN validation** is implemented directly in `classes.dex`.  
- Several **test API endpoints** are still present in `resources.arsc`.  
- The APK is signed properly with v2 scheme, but there’s **no obfuscation** (class names and methods are readable).  

Explain the **security risks** of this APK structure and what remediation steps developers should take.

---

**Answer (Summary):**

1. **Security Risks**  
- **Exposed PIN validation logic:** Readable client-side logic may allow bypass or brute-force attacks.  
- **No obfuscation:** Class/method names visible, reverse-engineering becomes trivial.  
- **Test endpoints in resources:** Attackers can abuse staging APIs; if creds overlap with prod, risk of data leaks.

2. **Remediation**  
- Move **PIN validation and sensitive logic server-side**.  
- Enable **R8/ProGuard obfuscation** to protect bytecode.  
- Exclude staging endpoints, debug configs, and unused keys from release builds.  
- Use CI/CD static scans to detect secrets and enforce obfuscation.

---

**Interview One-Liner:**  
“Even with v2 signing, lack of obfuscation and client-side PIN validation make reverse engineering trivial. Critical logic must be server-side, obfuscation enforced, and test endpoints removed from release builds.”